<include/common/vendor-token.conf>
<include/common/tokens.conf>
<include/components/volume.conf>
<include/components/host.conf>
<include/components/buffer.conf>
<include/components/pipeline.conf>
<include/controls/mixer.conf>
<include/controls/bytes.conf>
<include/pipelines/volume-playback.conf>
<include/pipelines/volume-capture.conf>
<include/pipelines/passthrough-capture.conf>
<include/components/dai.conf>
<include/components/virtual.conf>
<include/common/data.conf>
<include/common/pcm.conf>
<include/common/pcm_caps.conf>
<include/common/fe_dai.conf>
<include/dais/ssp.conf>
<include/dais/hda.conf>
<include/dais/hw_config.conf>
<include/dais/dmic.conf>
<include/dais/pdm_config.conf>
<include/common/route.conf>
<include/pipelines/kfb-capture.conf>
<include/pipelines/sound-detect.conf>
<include/components/kpb.conf>
<include/components/kpb_data.conf>
<include/components/detect.conf>
<include/components/detect_data.conf>
<include/components/selector.conf>
<include/components/selector_data.conf>

#
# DAIs configuration
#

Object.Dai {
	SSP.0 {
		id 0
		name SSP0-Codec
		default_hw_conf_id	0
		sample_bits 24
		clks_control 0
		bclk_delay 0
		quirks "lbm_mode"
		frame_pulse_width 0
		Object.Base.hw_config."SSP0" {
			id 0
			bclk_freq 4800000
			mclk_freq 24000000
			tdm_slot_width 25
		}

		# playback DAI is SSP(SPP_INDEX) using 2 periods
		# Buffers use s24le format, with 48 frame per 1000us on core 0 with priority 0
		Object.Widget.dai.0 {
			index  1
			dai_index 0
			type "dai_in"
			dai_type "SSP"
			direction "playback"
			stream_name "SSP0-Codec"
			period_sink_count 0
			period_source_count 2
			format s24le
		}

		# capture DAI is SSP(SSP_INDEX) using 2 periods
		# Buffers use s24le format, with 48 frame per 1000us on core 0 with priority 0
		Object.Widget.dai.1 {
			index  2
			dai_index 0
			type "dai_out"
			dai_type "SSP"
			direction "capture"
			stream_name "SSP0-Codec"
			period_sink_count 2
			period_source_count 0
			format s24le
		}
	}

	HDA.0 {
		name iDisp1
		id 3
		default_hw_conf_id 3
		Object.Base.hw_config.HDA0 {
			id 3
		}
		# playback DAI is iDisp1 using 2 periods
		# Buffers use s32le format, with 48 frame per 1000us on core 0 with priority 0
		Object.Widget.dai.0 {
			index 4
			dai_index 0
			type "dai_in"
			dai_type "HDA"
			direction "playback"
			stream_name "iDisp1"
			period_sink_count 0
			period_source_count 2
			format s32le
		}
	}
	HDA.1 {
		name iDisp2
		id 4
		default_hw_conf_id 4
		Object.Base.hw_config.HDA1 {
			id 4
		}
		# playback DAI is iDisp2 using 2 periods
		# Buffers use s32le format, with 48 frame per 1000us on core 0 with priority 0
		Object.Widget.dai.0 {
			index 5
			dai_index 1
			type "dai_in"
			dai_type "HDA"
			direction "playback"
			stream_name "iDisp2"
			period_sink_count 0
			period_source_count 2
			format s32le
		}
	}
	HDA.2 {
		name iDisp3
		id 5
		default_hw_conf_id 5
		Object.Base.hw_config.HDA2 {
			id 5
		}
		# playback DAI is iDisp3 using 2 periods
		# Buffers use s32le format, with 48 frame per 1000us on core 0 with priority 0
		Object.Widget.dai.0 {
			index 6
			dai_index 2
			type "dai_in"
			dai_type "HDA"
			direction "playback"
			stream_name "iDisp3"
			period_sink_count 0
			period_source_count 2
			format s32le
		}
	}

	DMIC.0 {
		name dmic01
		id 1
		default_hw_conf_id 1
		num_pdm_active 2
		Object.Base.pdm_config."0_short" {
			ctrl_id 0
		}
		Object.Base.pdm_config."1_short" {
			ctrl_id 1
		}
		Object.Base.hw_config.DMIC0 {
			id 1
		}
		# capture DAI is DMIC01 using 2 periods
		# Buffers use s32le format, with 48 frame per 1000us on core 0 with priority 0
		Object.Widget.dai.0 {
			stream_name "dmic01"
			index 3
			dai_indax 0
			type "dai_out"
			direction "capture"
			dai_type "DMIC"
			period_sink_count 2
			period_source_count 0
			format s32le
		}
	}

	DMIC.1 {
		name dmic16k
		id 2
		default_hw_conf_id 2
		sample_rate 16000
		num_pdm_active 1
		Object.Base.pdm_config."0_short" {
			ctrl_id 0
		}
		Object.Base.hw_config.DMIC1 {
			id 2
		}
		# capture DAI is DMIC 1 using 3 periods
		# Buffers use s32le format, with 320 frame per 20000us on core 0 with priority 0
		Object.Widget.dai.0 {
			stream_name "dmic16k"
			index 8
			dai_indax 1
			type "dai_out"
			direction "capture"
			dai_type "DMIC"
			period_sink_count 3
			period_source_count 0
			format s32le
		}
	}
}


#
# Define the pipelines
#
# PCM0 <---> volume <----> SSP(SSP_INDEX, BE link 0)
# PCM1 <---- DMICPROC <--- DMIC01 (dmic0 capture, , BE link 1)
# PCM2 ----> volume -----> iDisp1 (HDMI/DP playback, BE link 3)
# PCM3 ----> volume -----> iDisp2 (HDMI/DP playback, BE link 4)
# PCM4 ----> volume -----> iDisp3 (HDMI/DP playback, BE link 5)
# PCM8  <-------(pipe 8) <------------+- KPB 0 <----- DMIC1 (dmic16k, BE link 2)
#                                     |
# Detector <--- selector (pipe 9) <---+
#
Object.Pipeline {
	# Low Latency playback pipeline 1 on PCM 0 using max 2 channels of s24le.
	# Schedule 1000us deadline on core 0 with priority 0
	volume-playback.1 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		Object.Widget.pipeline.1 {
			stream_name 'dai.SSP.0.playback'
		}
		Object.Widget.host.playback {
			stream_name 'Passthrough Playback 0'
		}
		Object.Widget.pga.1 {
			Object.Control.mixer.1 {
				name '1 Master Playback Volume'
				access [
					'read_write'
					'tlv_read'
				]
			}
		}
		format s24le
	}

	# Low Latency capture pipeline 2 on PCM 0 using max 2 channels of s24le.
	# Schedule 1000us deadline on core 0 with priority 0
	volume-capture.2 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		Object.Widget.pipeline.1 {
			stream_name 'dai.SSP.0.capture'
		}
		Object.Widget.host.capture {
			stream_name 'Passthrough Capture 0'
		}
		Object.Widget.pga.1 {
			Object.Control.mixer.1 {
				name '2 Master Capture Volume'
				max 80
				access [
					'read_write'
					'tlv_read'
				]
			}
		}
		format s24le
	}

	# DMICPROC capture pipeline 3 on PCM 1 using max 4 channels.
	# Schedule 1000us deadline on core 0 with priority 0
	passthrough-capture.3 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		Object.Widget.pipeline.1 {
			stream_name 'dai.DMIC.0.capture'
		}
		Object.Widget.host.capture {
			stream_name 'Passthrough Capture 1'
		}
		format s32le
	}

	# Low Latency playback pipeline 4 on PCM 2 using max 2 channels of s32le.
	# Schedule 1000us deadline on core 0 with priority 0
	volume-playback.4 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		Object.Widget.pipeline.1 {
			stream_name 'dai.HDA.0.playback'
		}
		Object.Widget.host.playback {
			stream_name 'Passthrough Playback 2'
		}
		Object.Widget.pga.1 {
			Object.Control.mixer.1 {
				name '4 Master Playback Volume'
				access [
					'read_write'
					'tlv_read'
				]
			}
		}
		format s32le
	}

	# Low Latency playback pipeline 5 on PCM 3 using max 2 channels of s32le.
	# Schedule 1000us deadline on core 0 with priority 0
	volume-playback.5 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		Object.Widget.pipeline.1 {
			stream_name 'dai.HDA.1.playback'
		}
		Object.Widget.host.playback {
			stream_name 'Passthrough Playback 3'
		}
		Object.Widget.pga.1 {
			Object.Control.mixer.1 {
				name '5 Master Playback Volume'
				access [
					'read_write'
					'tlv_read'
				]
			}
		}
		format s32le
	}

	# Low Latency playback pipeline 6 on PCM 4 using max 2 channels of s32le.
	# Schedule 1000us deadline on core 0 with priority 0
	volume-playback.6 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		Object.Widget.pipeline.1 {
			stream_name 'dai.HDA.2.playback'
		}
		Object.Widget.host.playback {
			stream_name 'Passthrough Playback 4'
		}
		Object.Widget.pga.1 {
			Object.Control.mixer.1 {
				name '6 Master Playback Volume'
				access [
					'read_write'
					'tlv_read'
				]
			}
		}
		format s32le
	}

	# Passthrough capture pipeline 8 on PCM 7 using max 2 channels.
	# Schedule 20000us deadline on core 0 with priority 0
	kpb-capture.8 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 0
		period 5000
		Object.Widget.pipeline.1 {
			stream_name 'dai.DMIC.1.capture'
		}
		Object.Widget.host.capture {
			stream_name 'Sound Trigger Capture 8'
		}
		Object.Widget.kpb.1 {
			Object.Control.bytes.1 {
				name "KPB"
				max 304
				access [
					'tlv_read_write'
					'tlv_callback'
				]
				Object.Base.data."kpb_priv" {}
			}
		}
		format s24le
	}
	# keyword detector pipe
	sound-detect.9 {
		dynamic_pipeline @DYNAMIC_PIPELINE@
		core 0
		frames 0
		priority 1
		period 5000
		Object.Widget.pipeline.1 {
			stream_name 'dai.DMIC.1.capture'
		}
		Object.Widget.detect.1 {
			stream_name "Sound Trigger Capture 8"
			Object.Control.bytes.1 {
				name "Detector Config"
				max 304
				access [
					'tlv_read_write'
					'tlv_callback'
				]
				Object.Base.data."dummy_detect_config" {}
			}
			Object.Control.bytes.2 {
				name "Hotword Model"
				max 300000
				access [
					'tlv_read_write'
					'tlv_callback'
				]
				Object.Base.data."dummy_detect_model" {}
			}
		}
		Object.Widget.selector.1 {
			Object.Control.bytes.1 {
				name "SELECTOR"
				max 304
				access [
					'tlv_read_write'
					'tlv_callback'
				]
				Object.Base.data."selector_priv" {}
			}
		}
		format s24le
	}
}

#
# PCM configuration
#
Object.PCM {
	pcm.0 {
		name "Port1"
		direction "duplex"
		Object.Base.fe_dai."Port1" {}
		Object.PCM.pcm_caps."playback" {
			name "Passthrough Playback 0"
			formats 'S24_LE,S16_LE'
		}
		Object.PCM.pcm_caps."capture" {
			name "Passthrough Capture 0"
			formats 'S24_LE,S16_LE'
		}
	}
	pcm.1 {
		name "DMIC"
		direction "capture"
		Object.Base.fe_dai."DMIC" {}
		Object.PCM.pcm_caps."capture" {
			name "Passthrough Capture 1"
			formats 'S32_LE'
			channels_max 4
			channels_min 4
		}
	}
	pcm.2 {
		name "HDMI1"
		direction "playback"
		Object.Base.fe_dai."HDMI1" {}
		Object.PCM.pcm_caps."playback" {
			name "Passthrough Playback 2"
		}
	}
	pcm.3 {
		name "HDMI2"
		direction "playback"
		Object.Base.fe_dai."HDMI2" {}
		Object.PCM.pcm_caps."playback" {
			name "Passthrough Playback 3"
		}
	}
	pcm.4 {
		name "HDMI3"
		direction "playback"
		Object.Base.fe_dai."HDMI3" {}
		Object.PCM.pcm_caps."playback" {
			name "Passthrough Playback 4"
		}
	}
	pcm.8 {
		name "DMIC16kHz"
		direction "capture"
		capture_compatible_d0i3 1
		Object.Base.fe_dai."DMIC16kHz" {}
		Object.PCM.pcm_caps."capture" {
			name "Sound Trigger Capture 8"
			formats 'S24_LE,S16_LE'
			buffer_size_max 1280000
			buffer_size_min 537600
			period_size_max 256000
			period_size_min 192
			periods_max 160
			periods_min 2
			rate_max 16000
			rate_min 16000
		}
	}
}
#
# Graph configuration
#
Object.Base.route.1 {
	source 'buffer.1.2'
	sink 'dai.SSP.0.playback'
}
Object.Base.route.2 {
	source 'dai.SSP.0.capture'
	sink 'buffer.2.2'
}
Object.Base.route.3 {
	source 'dai.DMIC.0.capture'
	sink 'buffer.3.1'
}
Object.Base.route.4 {
	source 'buffer.4.2'
	sink 'dai.HDA.0.playback'
}
Object.Base.route.5 {
	source 'buffer.5.2'
	sink 'dai.HDA.1.playback'
}
Object.Base.route.6 {
	source 'buffer.6.2'
	sink 'dai.HDA.2.playback'
}
Object.Base.route.7 {
	source 'dai.DMIC.1.capture'
	sink 'buffer.8.2'
}
Object.Base {
	route.8 {
		source 'virtual."DETECT SINK 9"'
		sink 'host.8.capture'
	}
	route.9 {
		source 'kpb.8.1'
		sink 'buffer.9.2'
	}
}
