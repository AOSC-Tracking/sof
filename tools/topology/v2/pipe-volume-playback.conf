# "DefineTemplate" doesn't seem to be needed
#DefineTemplate."pipeline.volume-playback" {

#C_CONTROLMIXER(Master Playback Volume, PIPELINE_ID,
#	CONTROLMIXER_OPS(volsw, 256 binds the mixer control to volume get/put handlers, 256, 256),
#	CONTROLMIXER_MAX(, 32),
#	false,
#	CONTROLMIXER_TLV(TLV 32 steps from -64dB to 0dB for 2dB, vtlv_m64s2),
#	Channel register and shift for Front Left/Right,
#	LIST(`	', KCONTROL_CHANNEL(FL, 1, 0), KCONTROL_CHANNEL(FR, 1, 1)))

	controlmixer {
		# "pipeline_id" is a global attribute, it's available to all objects

		# mixercontrol.conf will have two attributes: "name" of type string
		# and "pipe_prepend" of type bool. If pipe_prepend == true, prepend
		# pipeline ID to the name. In m4 it was done as
		# ifdef(`CONTROL_NAME', CONTROL_NAME, $2 $1)
		name "Master Playback Volume"
		pipeline_prepend true

		channels [
			{
				name "FL"
				reg 1
				shift 0
			}
			{
				name "FR"
				reg 1
				shift 1
			}
		]

		op_info "volsw"
		op_get 256
		op_put 256

		max 32
		invert false
		tlv "vtlv_m64s2"
	}

#W_PCM_PLAYBACK(PCM_ID, Passthrough Playback, 2, 0)
	widget."pcm" {
		# "pipe_id" is a global attribute, it is available to all objects

		type aif_in

		# PCM names always have the pipeline ID appended to them
		name "Passthrough Playback "

		# global attributes, that specify "token" in their declarations
		periods_sink 2
		periods_source 0
	}

	widget."pga" {
		# "pipe_id" amd "format" are global attributes, it will be available to all objects

		pga_id 0
		periods_sink $dai_periods
		# no way to avoid this ^^^
		periods_source 2

		# set any additional token attributes
		volume_ramp_step_type 0
		volume_ramp_step_ms 250

		kcontrols [
# W_PGA is usually used with 1 kcontrol. It can be:
# "PIPELINE_ID Master Playback Volume"
# "PIPELINE_ID Master Capture Volume"
# "PIPELINE_ID PCM PCM_ID Playback Volume"
# "PIPELINE_ID PCM PCM_ID Capture Volume"
#define(`CONTROL_NAME', Capture Volume)
# "CONTROL_NAME"
# "PIPELINE_ID Tone Volume"
# but sometimes also with 2 kcontrols:
#define(`CONTROL_NAME_VOLUME', Capture Volume)
#define(`CONTROL_NAME_SWITCH', Capture Switch)
# "CONTROL_NAME_VOLUME", "CONTROL_NAME_SWITCH"
# In almost all above cases PGA kcontrols begin with the PIPELINE_ID, except in
# pipe-eq-capture.m4 and pipe-eq-capture-16khz.m4
			"Master Playback Volume"
		]
	}

	widget."buffer" {
		name 0
		format $pipeline_format
		periods 2
		#buf_size {}
		# buffer size calculated by the compiler
		capabilities $platform_host_mem_cap
	}

	widget."buffer" {
		name 1
		format $dai_format
		periods $dai_periods
		#buf_size {}
		# buffer size calculated by the compiler
		capabilities $platform_dai_mem_cap
	}

# The original pipe-volume-playback.m4 and similar pipeline definition m4 files
# don't instantiate the actual pipeline widgets, that's done in DAI pipeline
# files, e.g. in pipe-dai-playback.m4 instead. Now we can instantiate pipelines
# in all pipe-*.conf files since now we know to which DAIs they are all
# connected.

	widget."pipeline" {
		# tokens are inherited from machine.conf
		#tokens $pipeline_platform_tokens
		# The DAI will be used as the scheduling component / pipeline
		# stream name
	}

	graph {
		name "pipe-pass-vol-playback"
		links [
			{
				source "pcm"
				sink "buffer.0"
			}
			{
				source "buffer.0"
				sink "pga"
			}
			{
				source "pga"
				sink "buffer.1"
			}
		]
	}

# PCM_CAPABILITIES(Passthrough Playback PCM_ID, `S32_LE,S24_LE,S16_LE', PCM_MIN_RATE, PCM_MAX_RATE, 2, PIPELINE_CHANNELS, 2, 16, 192, 16384, 65536, 65536)
	pcm_capabilities {
		formats [
			s32le
			s24le
			s16le
		]
		channels {
			min 2
			max $pipeline_channels
		}
		periods {
			min 2
			max 16
		}
		period_size {
			min 192
			max 16384
		}
		buffer_size {
			min 65536
			max 65536
		}
	}
#}
