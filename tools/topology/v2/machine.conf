# Instantiate a subtree - all the pipelines, connected to one DAI
subtree {
	# Subtree-level attributes

	# the DAI will use pipeline_id from the first pipeline in the array
	# We put all the DAI attributes in the global scope, but in principle
	# the compiler can also be taught to take them from the DAI scope.
	dai_format s32le
	dai_periods 2
	dai_type HDA
	dai_index 4
        schedule_time_domain timer

	# the below could also be written as "pipelines.0 {...}" especially in
	# cases with only one pipeline in the subtree

	# Each element of this array instantiates a block, as defined per
	# DefineWidget."pipeline"
	# TODO: this has to be made explicit
	pipelines [
		{
			template "volume-playback"

			pipeline_id 7
			pipeline_channels 2
			pipeline_format s24le
			pipeline_rate 48000

			schedule_period 1000
			schedule_priority 0
			# optional: 0 core is the default
			schedule_core 0

			pcm_id 3
			pcm_rate {
				min 48000
				max 48000
			}

			tokens [
				{
					# from bxt.m4, cnl.m4
					sched_mips 5000
				}
			]

			# Not every pipeline has a PCM, some pipelines might
			# just form an alternative path in a graph, so a PCM in
			# a pipeline is optional, but common
			# PCM_PLAYBACK_ADD(HDMI1, 3, PIPELINE_PCM_7)
			# adds a "SectionPCM" block
			pcm {
				name "HDMI1"
			}
		}
	]

	# Instantiate a block, as defined per
	# DefineWidget."dai"
	# TODO: this has to be made explicit
	dai {
		# DAI-specific attributes
		template "playback"
		backend "iDisp1"
	}

	# The fourth parameter is the BE name and it seems to always be equal to
	# the fifth parameter of the DAI_ADD() macro, however, this hasn't been
	# verified in all topologies.
	# DAI_CONFIG(HDA, 4, 1, iDisp1)
	# Possibly this can be merged with the "dai" block above
	dai_config {
		id 1
	}

	# Need to instantiate SectionHWConfig separately
	hw_config {
		id 1
	}
}
