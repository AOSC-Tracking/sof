#!/bin/bash
##############################################################################
# Variant Definitions
#-----------------------------------------------------------------------------
#/-- General Definitions -----------------------------------------------------
SAT_ROOT=$(dirname `pwd`/$0)
ASSIST_BIN=$SAT_ROOT/tools
PROJ_NAME=sof-test-suites
PROJ_ROOT=$SAT_ROOT/$PROJ_NAME
PROJ_PLUG=$SAT_ROOT/extensions/test-result
FORCE_CONFIRMED=false
OUTPUT_ROOT=$SAT_ROOT/out
OUTPUT_TYPE=text
LOG_FILE=result.txt
RESOURCE_ROOT=/etc/sof/audio-test-res

#\----------------------------------------------------------------------------

#/-- Resource Definitions ----------------------------------------------------
STR_PROPMT_NEW_PROJECT="Project(%s) Missed , create project now?(Yes/no): "
STR_PROPMT_NEW_SUITE="Test suite(%s) Missed , create test suite now?(Yes/no): "

D_KEYWORDS_POOL=__keywords__
F_SUITE_CONF=_suite.conf
F_INIT_SH=_init_
F_UNINIT_SH=_uninit_
#\----------------------------------------------------------------------------

#/-- Other Definitions -------------------------------------------------------
OPERATE_ORDER=(o s e C c u l x)
TEST_SUITES=()
NDEBUG=
#\----------------------------------------------------------------------------

#/-- Export Definitions ------------------------------------------------------
export SAT_ROOT ASSIST_BIN NDEBUG REPORT_ROOT PROJ_ROOT
export REPORT_TYPE RESOURCE_ROOT TEST_SUITES 
#\----------------------------------------------------------------------------
# END: Config File Load
##############################################################################

##############################################################################
# BEG: Includes scripts
. sat-fw/conf-key.lst
. sat-fw/at-utils
. sat-fw/at-conf
. sat-fw/at-framework
. sat-fw/at-plugin
# END: Includes scripts
##############################################################################

# usage information
function usage
{
    cat <<!
usage: sat [options]
Run the automation test suites according specified test project.

  -p {PROJECT}                  Specified the test project which contains all relative test suites for this project;
                                if -p isn't present, current default project will be used. (sof-test-suites),
                                if the {PROJECT} doesn't exist, it will prompt user to confirm if need create a {PROJECT};
                                if -f option present, the {PROJECT} will be created automatically.

  -s {SUITE[;SUITE2;...]}       Select test suite {SUITE}, if not exist, create one manually or automatically (-f present);

  -o {REPORT_ROOT}              Test report output directory, default output is under test project, named 'report' (TODO);
  -C {KEY=VAL[;KEY2=VAL2;...]}  Specified the customized definition varibles which need saved as project level;
                                e.g.: tplg=sof-apl-pcm512x.tplg;key=val;

  -c {KEY=VAL[;KEY2=VAL2;...]}  Specified the customized definition varibles which need saved to specified test suites,
                                it will check the option -s as target test suites;
                                e.g.: -s platform/byt/mnb -c tplg=sof-apl-pcm512x.tplg;key=val;

  -e {SUTIE=y|n[;SUITE2=y|n;...]}  Enable/disable the test suite with following format: 
                                   test_suite1=y;test_suite2=n;test_suite3/sub_suite=y; the suite is the relative path of project root;


  -f Force confirmed when the new project or case suite missed, and need create automatically;
  -u Update the whole project's status if cases/suites changed. (TODO)
  -l List the project's test suites or suites' cases (TODO);
  -x Execute the test project or test suites (need match the option -s for specified executing test suites);
  -h Show this help;

example:
    1. run the suite1 of myProject
    sat -p myProject -s suite1 -x

    2. query how many test suites in the myProject
    sat -p myProject -l

    3. add the new test suites in the myProject
    sat -p myProject -s newSuite

    4. set the common varible for myProject
    sat -p myProject -C MY_VAR=value1

    5. set the common varible for suite2 of myProject
    sat -p myProject -s suite2 -c SUB_VAR=value2
!
}

# create a test project
# param: $1 projName
function create_project
{
    local projName=$1
    PROJ_ROOT=$SAT_ROOT/$projName
    if [[ $FORCE_CONFIRMED == true ]]; then
        mkdir -p $PROJ_ROOT
        conf_new_proj $PROJ_ROOT/$F_SUITE_CONF
        conf_general_upd $PROJ_ROOT/$F_SUITE_CONF $K_REPORT_ROOT"=$REPORT_ROOT"
        conf_general_upd $PROJ_ROOT/$F_SUITE_CONF $K_REPORT_TYPE"=$REPORT_TYPE"
        conf_general_upd $PROJ_ROOT/$F_SUITE_CONF $K_ASSIST_BIN"=$ASSIST_BIN"
    else
        printf "$STR_PROPMT_NEW_PROJECT" $projName
        read comfirmed
        if [[ $comfirmed == 'no' ]]; then
            loge "No valid project, failed to run the auto test..."
            exit 1
        else
            mkdir -p $PROJ_ROOT
            conf_new_proj $PROJ_ROOT/$F_SUITE_CONF
        fi
    fi
}

# process the input operator options
# param: $* optArray
function process_options
{
    local optArray=($*)
    for o in ${OPERATE_ORDER[@]}; do
        for i in ${optArray[@]}; do
            if [[ $o == ${i%:*} ]]; then
                case $o in
                    s)  # select test suite, if not exist, create one manually or automatically.
                        # it is used for -l & -c
                        local suite=${i#*:}
                        local suiteArray=(${suite//;/ })

                        for ts in ${suiteArray[@]}; do
                            # relevant path convert to abosulate path
                            [[ ${ts:0:1} != '/' ]] && ts=$PROJ_ROOT/$ts

                            if [[ ! -d $ts ]]; then
                                if [[ $FORCE_CONFIRMED == true ]]; then
                                    mkdir -p $ts
                                    conf_new_suite $ts/$F_SUITE_CONF
                                fi

                                # TODO: current only support create test suite under 1-level project directory.
                                # need be extented no limited directory depth in furture.
                                printf "$STR_PROPMT_NEW_SUITE" `basename $ts`
                                read comfirmed
                                if [[ $comfirmed == 'no' ]]; then
                                    logw "Invalid test suite, skip to preparing load ..."
                                    continue
                                else
                                    logw "TODO: test suite need be created!"
                                    mkdir -p $ts
#                                    conf_new_suite $ts/$F_SUITE_CONF
                                fi
                            fi
                            TEST_SUITES=(${TEST_SUITES[@]} $ts)
                        done
                        ;;

                    e)  # enable/disable test suites
                        local suite=${i#*:}
                        logi "Enabled/disable the suites: "$suite
                        local suiteArray=(${suite//;/ })
                        for ts in ${suiteArray[@]}; do
                                # relevant path convert to abosulate path
                            [[ ${ts:0:1} != '/' ]] && ts=$PROJ_ROOT/$ts
                            if [[ ! -d $ts ]]; then
                                logw "Invalid test suite `basename $ts`, failed to run the auto test..." # TODO: 1 depth dir limit
                                continue
                            fi
                            conf_suite_list_upd $PROJ_ROOT/$F_SUITE_CONF $ts
                        done
                        ;;

                    c)  # update customize keyvalues
                        local kv=${i#*:}
                        logi "Update customize the key-values pair: {"$kv"}"
                        for ts in ${TEST_SUITES[@]}; do
                            conf_customize_upd $ts/$F_SUITE_CONF $kv
                        done
                        ;;

                    C)  # update customize keyvalues for project level
                        local kv=${i#*:}
                        logi "Update customize the key-values pair: {"$kv"}"
                        conf_customize_upd $PROJ_ROOT/$F_SUITE_CONF $kv
                        ;;

                    u)  # TODO: update the whole project's status if cases/suites changed.
                        ;;

                    l)  # list the project's test suites or suites' cases
                        if [[ ${#TEST_SUITES[@]} -eq 0 ]]; then
                            # list the project's test suites
                            local list=$(conf_suite_list_load $PROJ_ROOT/$F_SUITE_CONF)
                            logi "---------------------- SUITE LIST ---------------------"
                            for item in ${list[@]}; do
                                logi $item
                            done
                            logi "-------------------------------------------------------"
                        else
                            # TODO: show the suites' case list
                            echo 'TODO'
                        fi
                        ;;

                    o)  # update log output & output type
                        conf_general_upd $PROJ_ROOT/$F_SUITE_CONF $K_REPORT_ROOT"=$REPORT_ROOT"
                        conf_general_upd $PROJ_ROOT/$F_SUITE_CONF $K_REPORT_TYPE"=$REPORT_TYPE"
                        ;;

                    x)  # execute the test project or test suite

                        prepare_project $PROJ_ROOT

                        # TODO: need use a option to enable/disable plugins
                        # currently, only support a set plugins for project.
                        init_plugin $PROJ_PLUG `cat $PROJ_PLUG/_vlist_`

                        logw "test suite size:"${#TEST_SUITES[@]}
                        local suitesStat="{}"
                        if [[ ${#TEST_SUITES[@]} -eq 0 ]]; then
                            # list the project's test suites
                            local list=$(conf_suite_list_load $PROJ_ROOT/$F_SUITE_CONF)
                            echo ${list[@]}
                            for item in ${list[@]}; do
                                if [[ ${item#*=} == y ]]; then
                                    local suite=$PROJ_ROOT/${item%=*}
                                    mkdir -p $OUTPUT_ROOT/`basename $suite`
                                    execute_suite $suite | tee $OUTPUT_ROOT/`basename $suite`/$LOG_FILE
                                fi
                            done
                        else
                            for ts in ${TEST_SUITES[@]}; do
                                mkdir -p $OUTPUT_ROOT/`basename $suite`
                                execute_suite $ts | tee $OUTPUT_ROOT/`basename $suite`/$LOG_FILE
                            done
                        fi

                        uninit_plugin
                        finished_project $PROJ_ROOT
                        ;;
                esac
                break
            fi
        done
    done
}

#/----------------------------------------------------------------------------
#| AT Main Entrance
#/----------------------------------------------------------------------------
function __main__ #argv:$1 $2 $3 ...
{
    local execOpts=()
    while getopts ':c:C::e::fxlo::p::s::u' opt; do
        case $opt in
            f)
                logi "Automatic confirmed enabled!"
                FORCE_CONFIRMED=true
                ;;

            o)
                OUTPUT_ROOT=${OPTARG#:*}
                [[ $OUTPUT_ROOT != $OPTARG ]] && OUTPUT_TYPE=${OPTARG#*:}
                # TODO: verify if report type supported.
                logi "Set output report directory [$OUTPUT_ROOT] & type [$OUTPUT_TYPE]"
                execOpts=(${execOpts[@]} $opt:-)
                ;;

            p)
                logi "Select Project: "$OPTARG
                PROJ_NAME=$OPTARG
                [[ ! -d $SAT_ROOT/$PROJ_NAME ]] && create_project $PROJ_NAME
                PROJ_ROOT=$SAT_ROOT/$PROJ_NAME
                ;;

            C|c|e|x|s)
                execOpts=(${execOpts[@]} $opt:$OPTARG)
                ;;

            l|u)
                execOpts=(${execOpts[@]} $opt:-)
                ;;

            *)
                usage
                ;;
        esac
    done

    process_options ${execOpts[@]}
    exit 0
}
#\----------------------------------------------------------------------------

#-----------------------------------------------------------------------------
__main__ -p $PROJ_NAME $* #2>&1
